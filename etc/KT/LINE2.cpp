/**
 * 문제 설명
당신은 무한히 긴 줄 하나를 잘라 줄 n개로 나누려고 합니다.

당신은 줄을 하나만 자르거나, 이미 잘려있는 줄을 겹쳐 여러 줄을 한 번에 자를 수 있습니다.

예를 들어 n이 4일 경우, 다음과 같이 자를 수 있습니다.

긴 줄 하나를 잘라 두 줄로 나눕니다.
두 줄 중 하나를 잘라 세 줄로 나눕니다.
세 줄 중 하나를 잘라 네 줄로 나눕니다.
다음과 같이 자를 수도 있습니다.

긴 줄 하나를 잘라 두 줄로 나눕니다.
두 개의 줄을 겹쳐 한 번에 잘라 네 줄로 나눕니다.
하지만, 줄을 한 번에 자르는 개수에 따라 줄을 자르는 시간이 달라집니다. 한 번에 많은 줄을 자를수록 더 많은 시간이 걸리게 됩니다.

예를 들어 n = 4 이고, 줄을 자를 때 걸리는 시간은 다음과 같다고 가정해보겠습니다.

자르는 줄의 개수	소요되는 시간
1	2
2	3
다음과 같이 줄을 자를 수 있습니다.

긴 줄 하나를 잘라 두 줄로 나눕니다.
시간이 2만큼 소요됩니다.
두 줄 중 하나를 잘라 세 줄로 나눕니다.
시간이 2만큼 소요됩니다.
세 줄 중 하나를 잘라 네 줄로 나눕니다.
시간이 2만큼 소요됩니다.
총 6만큼 시간이 소요됐습니다.

다른 방법으로는 아래와 같이 자를 수도 있습니다.

긴 줄 하나를 잘라 두 줄로 나눕니다.
시간이 2만큼 소요됩니다.
두 개의 줄을 겹쳐 한 번에 잘라 네 줄로 나눕니다.
시간이 3만큼 소요됩니다.
총 5만큼 시간이 소요됐습니다. 5보다 더 빨리 줄 4개로 나누는 방법은 없습니다.

만들어야 하는 줄의 개수를 뜻하는 정수 n, 줄을 x개 잘랐을 때 소요되는 시간을 담은 1차원 정수 배열 times가 주어졌을 때 긴 줄 하나를 잘라 줄 n개로 나누는데 걸리는 최소 시간을 return 하도록 solution 함수를 완성해주세요.

단, 줄을 잘라 n개를 초과하면 안 됩니다.

제한사항
2 ≤ n ≤ 2,000
times의 길이 = ceil(n / 2)
ceil(x) 는 x의 소수점 첫째 자리에서 올림을 의미합니다. 예를 들어 ceil(3.2) = 4, ceil(3.7) = 4, ceil(3) = 3 입니다.
1 ≤ times의 원소 ≤ 1,000,000
times[i]는 줄을 i + 1개 잘랐을 때 소요되는 시간입니다.
times의 원소는 중복 없이 오름차순으로 정렬되어있습니다.
입출력 예
n	times	result
4	[2, 3]	5
5	[2, 4, 5]	8
6	[1, 2, 3]	5
입출력 예 설명
입출력 예 #1

문제 예시와 동일합니다.

입출력 예 #2

만들어야 하는 줄의 개수는 5개입니다. 줄을 자를 때 걸리는 시간은 다음과 같습니다.

자르는 줄의 개수	소요되는 시간
1	2
2	4
3	5
긴 줄 하나를 잘라 두 줄로 나눕니다.
시간이 2만큼 소요됩니다.
두 개의 줄을 겹쳐 한 번에 잘라 네 줄로 나눕니다.
시간이 4만큼 소요됩니다.
네 줄 중 하나를 잘라 다섯 줄로 나눕니다.
시간이 2만큼 소요됩니다.
총 8만큼 시간이 소요됐습니다. 8보다 더 빨리 줄 5개를 나누는 방법은 없습니다. 따라서 8을 return 해야 합니다.

입출력 예 #3

만들어야 하는 줄의 개수는 6개입니다. 줄을 자를 때 걸리는 시간은 다음과 같습니다.

자르는 줄의 개수	소요되는 시간
1	1
2	2
3	3
긴 줄 하나를 잘라 두 줄로 나눕니다.
시간이 1만큼 소요됩니다.
두 개의 줄을 겹쳐 한 번에 잘라 네 줄로 나눕니다.
시간이 2만큼 소요됩니다.
네 줄 중 두 개의 줄을 겹쳐 한 번에 잘라 여섯 줄로 나눕니다.
시간이 2만큼 소요됩니다.
총 5만큼 시간이 소요됐습니다. 5보다 더 빨리 줄 6개를 나누는 방법은 없습니다. 따라서 5를 return 해야 합니다.
 */

#include <string>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

bool visited[2001]={false,};
int solution(int n, vector<int> times) {
    int answer = INT_MAX;
    queue<pair<int,int>> q;
    q.push({1,0});
    while(!q.empty()){
        auto cur=q.front();q.pop();
        for(int i=0;i< times.size() && i+1<=cur.first;i++){
            if((i+1)*2+cur.first-(i+1)<=n){
                if((i+1)*2+cur.first-(i+1)==n)answer=min(answer,cur.second+ times[i]);
                if((i+1)*2+cur.first-(i+1)>n || visited[(i+1)*2+cur.first-(i+1)])continue;
                q.push({(i+1)*2+cur.first-(i+1),cur.second+ times[i]});
                visited[(i+1)*2+cur.first-(i+1)]=true;
            }
        }
    }
    return answer;
}